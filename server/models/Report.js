const mongoose = require("mongoose");

// Main Report schema
const reportSchema = new mongoose.Schema(
  {
    // Report title
    title: {
      type: String,
      required: true,
      trim: true,
    },

    // Report type
    type: {
      type: String,
      enum: [
        "sales",
        "inventory",
        "customer",
        "revenue",
        "product-performance",
        "marketing",
        "custom",
      ],
      required: true,
    },

    // Report summary/description
    summary: {
      type: String,
      trim: true,
    },

    // Report period
    period: {
      startDate: {
        type: Date,
        required: true,
      },
      endDate: {
        type: Date,
        required: true,
      },
      label: {
        type: String, // e.g., "Monthly", "Quarterly", "Annual"
      },
    },

    // Report data/metrics
    metrics: {
      type: mongoose.Schema.Types.Mixed,
    },

    // Report filters applied
    filters: {
      category: String,
      status: String,
      minAmount: Number,
      maxAmount: Number,
      tags: [String],
    },

    // Report status
    status: {
      type: String,
      enum: ["draft", "generated", "published", "archived"],
      default: "draft",
    },

    // Generated by
    generatedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },

    // Generated at
    generatedAt: {
      type: Date,
      default: Date.now,
    },

    // File attachments (PDF, Excel, etc.)
    attachments: [
      {
        fileName: String,
        fileUrl: String,
        fileType: String,
        fileSize: Number,
      },
    ],

    // Scheduled report settings
    isScheduled: {
      type: Boolean,
      default: false,
    },

    schedule: {
      frequency: {
        type: String,
        enum: ["daily", "weekly", "monthly", "quarterly", "annual"],
      },
      nextRunDate: Date,
      recipients: [String], // Email addresses
    },
  },
  {
    timestamps: true,
  }
);

// Indexes
reportSchema.index({ type: 1, createdAt: -1 });
reportSchema.index({ status: 1 });
reportSchema.index({ "period.startDate": 1, "period.endDate": 1 });
reportSchema.index({ generatedBy: 1 });

// Static method to generate sales report
reportSchema.statics.generateSalesReport = async function (startDate, endDate) {
  const Order = mongoose.model("Order");

  const orders = await Order.find({
    placedAt: { $gte: startDate, $lte: endDate },
    status: { $nin: ["cancelled"] },
  });

  const totalRevenue = orders.reduce((sum, order) => sum + order.pricing.grandTotal, 0);
  const totalOrders = orders.length;
  const averageOrderValue = totalOrders > 0 ? totalRevenue / totalOrders : 0;

  // Calculate comparison with previous period
  const periodLength = endDate - startDate;
  const prevStartDate = new Date(startDate - periodLength);
  const prevOrders = await Order.find({
    placedAt: { $gte: prevStartDate, $lt: startDate },
    status: { $nin: ["cancelled"] },
  });

  const prevRevenue = prevOrders.reduce((sum, order) => sum + order.pricing.grandTotal, 0);
  const revenueTrend = prevRevenue > 0 ? ((totalRevenue - prevRevenue) / prevRevenue) * 100 : 0;

  const report = await this.create({
    title: "Sales Summary Report",
    type: "sales",
    summary: `Total revenue of â‚¹${totalRevenue.toLocaleString()} from ${totalOrders} orders. ${revenueTrend >= 0 ? "Up" : "Down"} ${Math.abs(revenueTrend).toFixed(1)}% compared to previous period.`,
    period: {
      startDate,
      endDate,
      label: "Custom Period",
    },
    metrics: {
      totalRevenue,
      totalOrders,
      averageOrderValue,
      revenueTrend,
      previousRevenue: prevRevenue,
      topProducts: [], // Can be populated with additional query
    },
    status: "generated",
    generatedAt: new Date(),
  });

  return report;
};

// Static method to generate inventory report
reportSchema.statics.generateInventoryReport = async function () {
  const Product = mongoose.model("Product");

  const products = await Product.find({ isActive: true });

  const lowStockProducts = products.filter((p) => p.totalStock < 10);
  const outOfStockProducts = products.filter((p) => p.totalStock === 0);
  const totalProducts = products.length;
  const totalStock = products.reduce((sum, p) => sum + p.totalStock, 0);

  const report = await this.create({
    title: "Inventory Insights",
    type: "inventory",
    summary: `${lowStockProducts.length} products are nearing low stock levels. ${outOfStockProducts.length} products are out of stock. Consider restocking soon.`,
    period: {
      startDate: new Date(),
      endDate: new Date(),
      label: "Current",
    },
    metrics: {
      totalProducts,
      totalStock,
      lowStockCount: lowStockProducts.length,
      outOfStockCount: outOfStockProducts.length,
      lowStockProducts: lowStockProducts.map((p) => ({
        id: p._id,
        title: p.title,
        stock: p.totalStock,
      })),
    },
    status: "generated",
    generatedAt: new Date(),
  });

  return report;
};

// Static method to generate customer report
reportSchema.statics.generateCustomerReport = async function (startDate, endDate) {
  const User = mongoose.model("User");
  const Order = mongoose.model("Order");

  const newCustomers = await User.countDocuments({
    createdAt: { $gte: startDate, $lte: endDate },
  });

  const activeCustomers = await Order.distinct("userId", {
    placedAt: { $gte: startDate, $lte: endDate },
  });

  const report = await this.create({
    title: "Customer Engagement Report",
    type: "customer",
    summary: `${newCustomers} new customers joined. ${activeCustomers.length} customers made purchases during this period.`,
    period: {
      startDate,
      endDate,
      label: "Custom Period",
    },
    metrics: {
      newCustomers,
      activeCustomers: activeCustomers.length,
    },
    status: "generated",
    generatedAt: new Date(),
  });

  return report;
};

// Method to publish report
reportSchema.methods.publish = function () {
  this.status = "published";
  return this.save();
};

// Method to archive report
reportSchema.methods.archive = function () {
  this.status = "archived";
  return this.save();
};

module.exports = mongoose.model("Report", reportSchema);
